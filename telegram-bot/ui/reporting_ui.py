# Path: flashcard_v2/ui/reporting_ui.py
"""
Module ch·ª©a c√°c h√†m x√¢y d·ª±ng giao di·ªán ng∆∞·ªùi d√πng cho ch·ª©c nƒÉng
xem v√† qu·∫£n l√Ω b√°o c√°o l·ªói th·∫ª.
ƒê√£ s·ª≠a l·ªói ImportError (self-import) v√† SyntaxWarning (escape sequences).
C√°c thay ƒë·ªïi tr∆∞·ªõc ƒë√≥ (async, context, time format, reporter name, ...) v·∫´n ƒë∆∞·ª£c gi·ªØ.
"""
import logging
import html
import re
import asyncio
import math
from datetime import datetime, timezone, timedelta

# Import t·ª´ th∆∞ vi·ªán telegram
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
# from telegram.ext import ContextTypes # B·ªè import
from telegram.constants import ParseMode

# Import helpers v√† config
from utils.helpers import get_chat_display_name
from config import DEFAULT_TIMEZONE_OFFSET, REPORTS_PER_PAGE
from ui.core_ui import build_pagination_keyboard

logger = logging.getLogger(__name__)

# --- H√ÄM HELPER ESCAPE MARKDOWN V2 ---
def escape_md_v2(text):
    """H√†m helper ƒë·ªÉ escape c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát trong MarkdownV2."""
    if text is None:
        return ''
    escape_chars = r'_*[]()~`>#+=-|{}.!'
    return re.sub(f'([{re.escape(escape_chars)}])', r'\\\1', str(text))

# --- H√†m build_sets_with_reports_keyboard ---
def build_sets_with_reports_keyboard(reportable_sets_summary):
    """
    X√¢y d·ª±ng tin nh·∫Øn v√† b√†n ph√≠m hi·ªÉn th·ªã danh s√°ch c√°c b·ªô t·ª´ c√≥ b√°o c√°o l·ªói ƒëang ch·ªù.
    """
    log_prefix = "[UI_BUILD_REPORT_SETS]"
    logger.debug(f"{log_prefix} T·∫°o keyboard ch·ªçn b·ªô c√≥ b√°o c√°o l·ªói.")
    text = "üìä **C√°c b·ªô th·∫ª c√≥ b√°o c√°o l·ªói ƒëang ch·ªù x·ª≠ l√Ω:**\nCh·ªçn m·ªôt b·ªô ƒë·ªÉ xem chi ti·∫øt:"
    keyboard = []
    if not reportable_sets_summary:
        text = "üéâ Kh√¥ng c√≥ b√°o c√°o l·ªói n√†o ƒëang ch·ªù x·ª≠ l√Ω cho c√°c b·ªô th·∫ª c·ªßa b·∫°n."
        keyboard.append([InlineKeyboardButton("üîô Quay l·∫°i Menu Qu·∫£n l√Ω", callback_data="show_set_management")])
        return text, InlineKeyboardMarkup(keyboard)

    for set_info in reportable_sets_summary:
        set_id = set_info.get('set_id')
        title = set_info.get('title', f"B·ªô ID {set_id}")
        count = set_info.get('pending_count', 0)
        if set_id is None: continue
        button_text = f"üìö {html.escape(title)} ({count} l·ªói)"
        callback_data = f"view_set_reports:{set_id}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])

    keyboard.append([InlineKeyboardButton("üîô Quay l·∫°i Menu Qu·∫£n l√Ω", callback_data="show_set_management")])
    return text, InlineKeyboardMarkup(keyboard)

# --- H√†m build_reported_card_selection_keyboard ---
def build_reported_card_selection_keyboard(set_id, card_report_summary, current_page=1):
    """
    X√¢y d·ª±ng b√†n ph√≠m hi·ªÉn th·ªã danh s√°ch c√°c ID th·∫ª c√≥ b√°o c√°o l·ªói ƒëang ch·ªù trong m·ªôt b·ªô.
    H·ªó tr·ª£ ph√¢n trang v√† hi·ªÉn th·ªã theo h√†ng d·ªçc.
    """
    log_prefix = f"[UI_BUILD_REPORTED_CARD_SELECT|Set:{set_id}|Page:{current_page}]"
    logger.debug(f"{log_prefix} T·∫°o keyboard ch·ªçn flashcard_id b·ªã l·ªói.")

    kb_back_to_sets = [[InlineKeyboardButton("üîô Ch·ªçn b·ªô kh√°c", callback_data="view_reports_menu")]]
    markup_back_to_sets = InlineKeyboardMarkup(kb_back_to_sets)

    if not card_report_summary:
        # S·ª≠a escape sequence
        text = "Kh√¥ng c√≥ th·∫ª n√†o trong b·ªô n√†y c√≥ b√°o c√°o l·ªói ƒëang ch·ªù x·ª≠ l√Ω\\."
        return text, markup_back_to_sets

    # --- Logic ph√¢n trang ---
    items_per_page = REPORTS_PER_PAGE
    total_items = len(card_report_summary)
    total_pages = math.ceil(total_items / items_per_page)
    current_page = max(1, min(current_page, total_pages))
    start_index = (current_page - 1) * items_per_page
    end_index = start_index + items_per_page
    items_on_page = card_report_summary[start_index:end_index]
    # ------------------------

    # S·ª≠a escape sequence cho d·∫•u ngo·∫∑c ƒë∆°n
    text = (f"üóÇÔ∏è **C√°c th·∫ª c√≥ b√°o c√°o l·ªói trong b·ªô ID {set_id}:** "
            f"\\(Trang {current_page}/{total_pages}\\)\n"
            f"Ch·ªçn ID th·∫ª ƒë·ªÉ xem chi ti·∫øt l·ªói:")
    keyboard = []

    # --- T·∫°o n√∫t theo h√†ng d·ªçc ---
    if not items_on_page:
         text = f"üóÇÔ∏è **C√°c th·∫ª c√≥ b√°o c√°o l·ªói trong b·ªô ID {set_id}:**\nKh√¥ng c√≥ th·∫ª n√†o tr√™n trang n√†y."
    else:
        for summary in items_on_page:
            card_id = summary.get('flashcard_id')
            count = summary.get('report_count', 0)
            if card_id is None: continue
            button_text = f"ID: {card_id} ({count})"
            callback_data = f"view_card_reports:{card_id}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    # --------------------------

    # --- Th√™m n√∫t ph√¢n trang ---
    pagination_row = build_pagination_keyboard(current_page, total_pages, f"report_card_page:{set_id}")
    if pagination_row:
        keyboard.append(pagination_row)
    # -------------------------

    keyboard.extend(kb_back_to_sets) # Th√™m n√∫t quay l·∫°i cu·ªëi

    final_markup = InlineKeyboardMarkup(keyboard)
    logger.debug(f"{log_prefix} ƒê√£ t·∫°o keyboard ch·ªçn th·∫ª v·ªõi {len(items_on_page)} th·∫ª tr√™n trang {current_page}/{total_pages}.")
    return text, final_markup

# --- H√†m build_card_report_detail_display ---
async def build_card_report_detail_display(card_info, reports_list, context):
    """
    X√¢y d·ª±ng tin nh·∫Øn v√† b√†n ph√≠m hi·ªÉn th·ªã chi ti·∫øt th·∫ª v√† danh s√°ch b√°o c√°o l·ªói
    cho th·∫ª ƒë√≥. ƒê√£ s·ª≠a l·ªói ƒë·ªãnh d·∫°ng v√† escape, lo·∫°i b·ªè type hint.
    """
    if not card_info or not isinstance(card_info, dict) or 'flashcard_id' not in card_info:
        logger.error("[UI_BUILD_CARD_REPORT_DETAIL] Thi·∫øu th√¥ng tin th·∫ª.")
        return None, None
    if not context:
        logger.error("[UI_BUILD_CARD_REPORT_DETAIL] Thi·∫øu context.")
        return None, None

    flashcard_id = card_info['flashcard_id']
    set_id = card_info.get('set_id')
    log_prefix = f"[UI_BUILD_CARD_REPORT_DETAIL|Card:{flashcard_id}]"
    logger.debug(f"{log_prefix} T·∫°o hi·ªÉn th·ªã chi ti·∫øt th·∫ª v√† b√°o c√°o.")

    # --- N√∫t quay l·∫°i ---
    kb_back_to_cards = []
    if set_id is not None:
        kb_back_to_cards = [[InlineKeyboardButton("üîô Quay l·∫°i DS th·∫ª l·ªói", callback_data=f"view_set_reports:{set_id}")]]
    else:
        kb_back_to_cards = [[InlineKeyboardButton("üîô Quay l·∫°i Ch·ªçn b·ªô", callback_data="view_reports_menu")]]
    # markup_back_to_cards d√πng ·ªü cu·ªëi

    # --- Hi·ªÉn th·ªã th√¥ng tin th·∫ª ---
    card_front_raw = card_info.get('front', '(Tr·ªëng)')
    card_back_raw = card_info.get('back', '(Tr·ªëng)')
    # Ch·ªâ escape markdown, kh√¥ng escape html
    escaped_front = escape_md_v2(card_front_raw)
    escaped_back = escape_md_v2(card_back_raw)

    text_lines = [
        f"üîñ **Chi ti·∫øt th·∫ª ID `{flashcard_id}`**",
        f"‚ñ∂Ô∏è M·∫∑t tr∆∞·ªõc:\n{escaped_front}",
        f"‚óÄÔ∏è M·∫∑t sau:\n{escaped_back}",
        "\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-", # S·ª≠a escape sequence
        f"üö® **C√°c b√°o c√°o l·ªói ƒëang ch·ªù x·ª≠ l√Ω cho th·∫ª n√†y:**\n"
    ]

    keyboard = []

    if not reports_list:
        text_lines.append("\\_Kh√¥ng c√≥ b√°o c√°o n√†o\\.\\_") # S·ª≠a escape sequence
        keyboard.extend(kb_back_to_cards)
        return "\n".join(text_lines), InlineKeyboardMarkup(keyboard)

    # --- L·∫•y t√™n ng∆∞·ªùi b√°o c√°o ---
    bot_instance = context.bot
    reporter_telegram_ids = [r.get('reporter_telegram_id') for r in reports_list if r.get('reporter_telegram_id')]
    reporter_display_names = {}
    if reporter_telegram_ids:
        tasks = [get_chat_display_name(bot_instance, tg_id) for tg_id in reporter_telegram_ids]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        for i, tg_id in enumerate(reporter_telegram_ids):
            if isinstance(results[i], Exception):
                reporter_display_names[tg_id] = f"ID: {tg_id}"
            else:
                reporter_display_names[tg_id] = results[i]

    # --- Li·ªát k√™ c√°c b√°o c√°o ---
    report_count = 0
    for report in reports_list:
        report_id = report.get('report_id')
        reporter_user_id = report.get('reporter_user_id')
        reporter_telegram_id = report.get('reporter_telegram_id')
        report_text = report.get('report_text', '')
        reported_at_val = report.get('reported_at')

        if report_id is None: continue
        report_count += 1

        # ƒê·ªãnh d·∫°ng th·ªùi gian + √Åp d·ª•ng Timezone
        reported_time_str = "Kh√¥ng r√µ"
        if reported_at_val:
            dt_object_utc = None
            try:
                dt_object_utc = datetime.fromtimestamp(float(reported_at_val), tz=timezone.utc)
            except (ValueError, TypeError):
                try:
                    dt_object_utc = datetime.strptime(str(reported_at_val).split('.')[0], '%Y-%m-%d %H:%M:%S').replace(tzinfo=timezone.utc)
                except ValueError:
                    reported_time_str = str(reported_at_val)
            if dt_object_utc:
                try:
                    system_tz = timezone(timedelta(hours=DEFAULT_TIMEZONE_OFFSET))
                    dt_object_local = dt_object_utc.astimezone(system_tz)
                    reported_time_str = dt_object_local.strftime("%d/%m/%Y %H:%M")
                except Exception as tz_err:
                    reported_time_str = dt_object_utc.strftime("%d/%m/%Y %H:%M (UTC)")

        # L·∫•y t√™n hi·ªÉn th·ªã v√† t·∫°o mention
        reporter_display_str = f"`UID {reporter_user_id}`" # Fallback
        if reporter_telegram_id:
            display_name = reporter_display_names.get(reporter_telegram_id, f"ID: {reporter_telegram_id}")
            # Escape t√™n cho link MarkdownV2
            escaped_display_name = escape_md_v2(display_name).replace('[', '\\[').replace(']', '\\]')
            reporter_display_str = f"[{escaped_display_name}](tg://user?id={reporter_telegram_id})"

        # Escape n·ªôi dung b√°o c√°o v√† th·ªùi gian
        report_escaped_html = html.escape(report_text) # V·∫´n escape html cho n·ªôi dung nh·∫≠p t·ª± do
        report_truncated = (report_escaped_html[:100] + '...') if len(report_escaped_html) > 100 else report_escaped_html
        escaped_report_truncated_md = escape_md_v2(report_truncated)
        escaped_reported_time_str_md = escape_md_v2(reported_time_str)

        # Th√™m th√¥ng tin b√°o c√°o (s·ª≠a escape sequence)
        text_lines.append(f"*{report_count}\\.* B√°o c√°o b·ªüi {reporter_display_str}") # Escape .
        text_lines.append(f"   üïí Th·ªùi gian: {escaped_reported_time_str_md}")
        text_lines.append(f"   üí¨ N·ªôi dung: {escaped_report_truncated_md}\n")

    # --- T·∫°o n√∫t b·∫•m ---
    if report_count > 0:
        resolve_button_text = f"‚úÖ ƒê√£ s·ª≠a xong ({report_count} b√°o c√°o)"
        resolve_callback_data = f"resolve_card_reports:{flashcard_id}"
        keyboard.append([InlineKeyboardButton(resolve_button_text, callback_data=resolve_callback_data)])

    keyboard.extend(kb_back_to_cards)

    final_text = "\n".join(text_lines)
    final_markup = InlineKeyboardMarkup(keyboard)
    logger.debug(f"{log_prefix} ƒê√£ t·∫°o xong hi·ªÉn th·ªã chi ti·∫øt th·∫ª v√† b√°o c√°o (ƒë√£ s·ª≠a escape).")

    return final_text, final_markup